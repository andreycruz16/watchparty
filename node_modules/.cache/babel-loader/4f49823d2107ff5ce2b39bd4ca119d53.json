{"ast":null,"code":"var EOL = \"\\n\";\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\n\nfunction toXml(jArray, options) {\n  return arrToStr(jArray, options, \"\", 0);\n}\n\nfunction arrToStr(arr, options, jPath, level) {\n  var xmlStr = \"\";\n  var indentation = \"\";\n\n  if (options.format && options.indentBy.length > 0) {\n    //TODO: this logic can be avoided for each call\n    indentation = EOL + \"\" + options.indentBy.repeat(level);\n  }\n\n  for (var i = 0; i < arr.length; i++) {\n    var tagObj = arr[i];\n    var tagName = propName(tagObj);\n    var newJPath = \"\";\n    if (jPath.length === 0) newJPath = tagName;else newJPath = \"\".concat(jPath, \".\").concat(tagName);\n\n    if (tagName === options.textNodeName) {\n      var tagText = tagObj[tagName];\n\n      if (!isStopNode(newJPath, options)) {\n        tagText = options.tagValueProcessor(tagName, tagText);\n        tagText = replaceEntitiesValue(tagText, options);\n      }\n\n      xmlStr += indentation + tagText;\n      continue;\n    } else if (tagName === options.cdataPropName) {\n      xmlStr += indentation + \"<![CDATA[\".concat(tagObj[tagName][0][options.textNodeName], \"]]>\");\n      continue;\n    } else if (tagName === options.commentPropName) {\n      xmlStr += indentation + \"<!--\".concat(tagObj[tagName][0][options.textNodeName], \"-->\");\n      continue;\n    } else if (tagName[0] === \"?\") {\n      var _attStr = attr_to_str(tagObj[\":@\"], options);\n\n      xmlStr += indentation + \"<\".concat(tagName, \" \").concat(tagObj[tagName][0][options.textNodeName], \" \").concat(_attStr, \"?>\");\n      continue;\n    }\n\n    var attStr = attr_to_str(tagObj[\":@\"], options);\n    var tagStart = indentation + \"<\".concat(tagName).concat(attStr);\n    var tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);\n\n    if (options.unpairedTags.indexOf(tagName) !== -1) {\n      if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";else xmlStr += tagStart + \"/>\";\n    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n      xmlStr += tagStart + \"/>\";\n    } else {\n      //TODO: node with only text value should not parse the text value in next line\n      xmlStr += tagStart + \">\".concat(tagValue).concat(indentation, \"</\").concat(tagName, \">\");\n    }\n  }\n\n  return xmlStr;\n}\n\nfunction propName(obj) {\n  var keys = Object.keys(obj);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== \":@\") return key;\n  }\n}\n\nfunction attr_to_str(attrMap, options) {\n  var attrStr = \"\";\n\n  if (attrMap && !options.ignoreAttributes) {\n    for (var attr in attrMap) {\n      var attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n      attrVal = replaceEntitiesValue(attrVal, options);\n\n      if (attrVal === true && options.suppressBooleanAttributes) {\n        attrStr += \" \".concat(attr.substr(options.attributeNamePrefix.length));\n      } else {\n        attrStr += \" \".concat(attr.substr(options.attributeNamePrefix.length), \"=\\\"\").concat(attrVal, \"\\\"\");\n      }\n    }\n  }\n\n  return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n  var tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n\n  for (var index in options.stopNodes) {\n    if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n  }\n\n  return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n  if (textValue && textValue.length > 0 && options.processEntities) {\n    for (var i = 0; i < options.entities.length; i++) {\n      var entity = options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n\n  return textValue;\n}\n\nmodule.exports = toXml;","map":{"version":3,"sources":["/home/runner/work/watchparty/watchparty/node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"],"names":["EOL","toXml","jArray","options","arrToStr","arr","jPath","level","xmlStr","indentation","format","indentBy","length","repeat","i","tagObj","tagName","propName","newJPath","textNodeName","tagText","isStopNode","tagValueProcessor","replaceEntitiesValue","cdataPropName","commentPropName","attStr","attr_to_str","tagStart","tagValue","unpairedTags","indexOf","suppressUnpairedNode","suppressEmptyNode","obj","keys","Object","key","attrMap","attrStr","ignoreAttributes","attr","attrVal","attributeValueProcessor","suppressBooleanAttributes","substr","attributeNamePrefix","lastIndexOf","index","stopNodes","textValue","processEntities","entities","entity","replace","regex","val","module","exports"],"mappings":"AAAA,IAAMA,GAAG,GAAG,IAAZ;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,KAAT,CAAeC,MAAf,EAAuBC,OAAvB,EAA+B;AAC3B,SAAOC,QAAQ,CAAEF,MAAF,EAAUC,OAAV,EAAmB,EAAnB,EAAuB,CAAvB,CAAf;AACH;;AAED,SAASC,QAAT,CAAkBC,GAAlB,EAAuBF,OAAvB,EAAgCG,KAAhC,EAAuCC,KAAvC,EAA6C;AACzC,MAAIC,MAAM,GAAG,EAAb;AAEA,MAAIC,WAAW,GAAG,EAAlB;;AACA,MAAGN,OAAO,CAACO,MAAR,IAAkBP,OAAO,CAACQ,QAAR,CAAiBC,MAAjB,GAA0B,CAA/C,EAAiD;AAAC;AAC9CH,IAAAA,WAAW,GAAGT,GAAG,GAAG,EAAN,GAAWG,OAAO,CAACQ,QAAR,CAAiBE,MAAjB,CAAwBN,KAAxB,CAAzB;AACH;;AAED,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,GAAG,CAACO,MAAxB,EAAgCE,CAAC,EAAjC,EAAqC;AACjC,QAAMC,MAAM,GAAGV,GAAG,CAACS,CAAD,CAAlB;AACA,QAAME,OAAO,GAAGC,QAAQ,CAACF,MAAD,CAAxB;AACA,QAAIG,QAAQ,GAAG,EAAf;AACA,QAAGZ,KAAK,CAACM,MAAN,KAAiB,CAApB,EAAuBM,QAAQ,GAAGF,OAAX,CAAvB,KACKE,QAAQ,aAAMZ,KAAN,cAAeU,OAAf,CAAR;;AAEL,QAAGA,OAAO,KAAKb,OAAO,CAACgB,YAAvB,EAAoC;AAChC,UAAIC,OAAO,GAAGL,MAAM,CAACC,OAAD,CAApB;;AACA,UAAG,CAACK,UAAU,CAACH,QAAD,EAAWf,OAAX,CAAd,EAAkC;AAC9BiB,QAAAA,OAAO,GAAGjB,OAAO,CAACmB,iBAAR,CAA2BN,OAA3B,EAAoCI,OAApC,CAAV;AACAA,QAAAA,OAAO,GAAGG,oBAAoB,CAACH,OAAD,EAAUjB,OAAV,CAA9B;AACH;;AACDK,MAAAA,MAAM,IAAIC,WAAW,GAAGW,OAAxB;AACA;AACH,KARD,MAQM,IAAIJ,OAAO,KAAKb,OAAO,CAACqB,aAAxB,EAAsC;AACxChB,MAAAA,MAAM,IAAIC,WAAW,sBAAeM,MAAM,CAACC,OAAD,CAAN,CAAgB,CAAhB,EAAmBb,OAAO,CAACgB,YAA3B,CAAf,QAArB;AACA;AACH,KAHK,MAGA,IAAIH,OAAO,KAAKb,OAAO,CAACsB,eAAxB,EAAwC;AAC1CjB,MAAAA,MAAM,IAAIC,WAAW,iBAAUM,MAAM,CAACC,OAAD,CAAN,CAAgB,CAAhB,EAAmBb,OAAO,CAACgB,YAA3B,CAAV,QAArB;AACA;AACH,KAHK,MAGA,IAAIH,OAAO,CAAC,CAAD,CAAP,KAAe,GAAnB,EAAuB;AACzB,UAAMU,OAAM,GAAGC,WAAW,CAACZ,MAAM,CAAC,IAAD,CAAP,EAAeZ,OAAf,CAA1B;;AACAK,MAAAA,MAAM,IAAIC,WAAW,cAAOO,OAAP,cAAkBD,MAAM,CAACC,OAAD,CAAN,CAAgB,CAAhB,EAAmBb,OAAO,CAACgB,YAA3B,CAAlB,cAA8DO,OAA9D,OAArB;AACA;AACH;;AACD,QAAMA,MAAM,GAAGC,WAAW,CAACZ,MAAM,CAAC,IAAD,CAAP,EAAeZ,OAAf,CAA1B;AACA,QAAIyB,QAAQ,GAAInB,WAAW,cAAOO,OAAP,SAAiBU,MAAjB,CAA3B;AACA,QAAIG,QAAQ,GAAGzB,QAAQ,CAACW,MAAM,CAACC,OAAD,CAAP,EAAkBb,OAAlB,EAA2Be,QAA3B,EAAqCX,KAAK,GAAG,CAA7C,CAAvB;;AACA,QAAGJ,OAAO,CAAC2B,YAAR,CAAqBC,OAArB,CAA6Bf,OAA7B,MAA0C,CAAC,CAA9C,EAAgD;AAC5C,UAAGb,OAAO,CAAC6B,oBAAX,EAAkCxB,MAAM,IAAIoB,QAAQ,GAAG,GAArB,CAAlC,KACKpB,MAAM,IAAIoB,QAAQ,GAAG,IAArB;AACR,KAHD,MAGM,IAAI,CAAC,CAACC,QAAD,IAAaA,QAAQ,CAACjB,MAAT,KAAoB,CAAlC,KAAwCT,OAAO,CAAC8B,iBAApD,EAAsE;AACxEzB,MAAAA,MAAM,IAAIoB,QAAQ,GAAG,IAArB;AACH,KAFK,MAED;AACD;AACApB,MAAAA,MAAM,IAAIoB,QAAQ,cAAOC,QAAP,SAAkBpB,WAAlB,eAAkCO,OAAlC,MAAlB;AACH;AACJ;;AAED,SAAOR,MAAP;AACH;;AAED,SAASS,QAAT,CAAkBiB,GAAlB,EAAsB;AAClB,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYD,GAAZ,CAAb;;AACA,OAAK,IAAIpB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,IAAI,CAACvB,MAAzB,EAAiCE,CAAC,EAAlC,EAAsC;AACpC,QAAMuB,GAAG,GAAGF,IAAI,CAACrB,CAAD,CAAhB;AACA,QAAGuB,GAAG,KAAK,IAAX,EAAiB,OAAOA,GAAP;AAClB;AACF;;AAEH,SAASV,WAAT,CAAqBW,OAArB,EAA8BnC,OAA9B,EAAsC;AAClC,MAAIoC,OAAO,GAAG,EAAd;;AACA,MAAGD,OAAO,IAAI,CAACnC,OAAO,CAACqC,gBAAvB,EAAwC;AACpC,SAAK,IAAIC,IAAT,IAAiBH,OAAjB,EAAyB;AACrB,UAAII,OAAO,GAAGvC,OAAO,CAACwC,uBAAR,CAAgCF,IAAhC,EAAsCH,OAAO,CAACG,IAAD,CAA7C,CAAd;AACAC,MAAAA,OAAO,GAAGnB,oBAAoB,CAACmB,OAAD,EAAUvC,OAAV,CAA9B;;AACA,UAAGuC,OAAO,KAAK,IAAZ,IAAoBvC,OAAO,CAACyC,yBAA/B,EAAyD;AACrDL,QAAAA,OAAO,eAAOE,IAAI,CAACI,MAAL,CAAY1C,OAAO,CAAC2C,mBAAR,CAA4BlC,MAAxC,CAAP,CAAP;AACH,OAFD,MAEK;AACD2B,QAAAA,OAAO,eAAOE,IAAI,CAACI,MAAL,CAAY1C,OAAO,CAAC2C,mBAAR,CAA4BlC,MAAxC,CAAP,gBAA2D8B,OAA3D,OAAP;AACH;AACJ;AACJ;;AACD,SAAOH,OAAP;AACH;;AAED,SAASlB,UAAT,CAAoBf,KAApB,EAA2BH,OAA3B,EAAmC;AAC/BG,EAAAA,KAAK,GAAGA,KAAK,CAACuC,MAAN,CAAa,CAAb,EAAevC,KAAK,CAACM,MAAN,GAAeT,OAAO,CAACgB,YAAR,CAAqBP,MAApC,GAA6C,CAA5D,CAAR;AACA,MAAII,OAAO,GAAGV,KAAK,CAACuC,MAAN,CAAavC,KAAK,CAACyC,WAAN,CAAkB,GAAlB,IAAyB,CAAtC,CAAd;;AACA,OAAI,IAAIC,KAAR,IAAiB7C,OAAO,CAAC8C,SAAzB,EAAmC;AAC/B,QAAG9C,OAAO,CAAC8C,SAAR,CAAkBD,KAAlB,MAA6B1C,KAA7B,IAAsCH,OAAO,CAAC8C,SAAR,CAAkBD,KAAlB,MAA6B,OAAKhC,OAA3E,EAAoF,OAAO,IAAP;AACvF;;AACD,SAAO,KAAP;AACH;;AAED,SAASO,oBAAT,CAA8B2B,SAA9B,EAAyC/C,OAAzC,EAAiD;AAC7C,MAAG+C,SAAS,IAAIA,SAAS,CAACtC,MAAV,GAAmB,CAAhC,IAAqCT,OAAO,CAACgD,eAAhD,EAAgE;AAC9D,SAAK,IAAIrC,CAAC,GAAC,CAAX,EAAcA,CAAC,GAAEX,OAAO,CAACiD,QAAR,CAAiBxC,MAAlC,EAA0CE,CAAC,EAA3C,EAA+C;AAC7C,UAAMuC,MAAM,GAAGlD,OAAO,CAACiD,QAAR,CAAiBtC,CAAjB,CAAf;AACAoC,MAAAA,SAAS,GAAGA,SAAS,CAACI,OAAV,CAAkBD,MAAM,CAACE,KAAzB,EAAgCF,MAAM,CAACG,GAAvC,CAAZ;AACD;AACF;;AACD,SAAON,SAAP;AACD;;AACHO,MAAM,CAACC,OAAP,GAAiBzD,KAAjB","sourcesContent":["const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options){\n    return arrToStr( jArray, options, \"\", 0);\n}\n\nfunction arrToStr(arr, options, jPath, level){\n    let xmlStr = \"\";\n\n    let indentation = \"\";\n    if(options.format && options.indentBy.length > 0){//TODO: this logic can be avoided for each call\n        indentation = EOL + \"\" + options.indentBy.repeat(level);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        let newJPath = \"\";\n        if(jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if(tagName === options.textNodeName){\n            let tagText = tagObj[tagName];\n            if(!isStopNode(newJPath, options)){\n                tagText = options.tagValueProcessor( tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            xmlStr += indentation + tagText;\n            continue;\n        }else if( tagName === options.cdataPropName){\n            xmlStr += indentation + `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            continue;\n        }else if( tagName === options.commentPropName){\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            continue;\n        }else if( tagName[0] === \"?\"){\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            xmlStr += indentation + `<${tagName} ${tagObj[tagName][0][options.textNodeName]} ${attStr}?>`;\n            continue;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        let tagStart =  indentation + `<${tagName}${attStr}`;\n        let tagValue = arrToStr(tagObj[tagName], options, newJPath, level + 1);\n        if(options.unpairedTags.indexOf(tagName) !== -1){\n            if(options.suppressUnpairedNode)  xmlStr += tagStart + \">\"; \n            else xmlStr += tagStart + \"/>\"; \n        }else if( (!tagValue || tagValue.length === 0) && options.suppressEmptyNode){ \n            xmlStr += tagStart + \"/>\"; \n        }else{ \n            //TODO: node with only text value should not parse the text value in next line\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>` ;\n        }\n    }\n    \n    return xmlStr;\n}\n\nfunction propName(obj){\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if(key !== \":@\") return key;\n    }\n  }\n\nfunction attr_to_str(attrMap, options){\n    let attrStr = \"\";\n    if(attrMap && !options.ignoreAttributes){\n        for (let attr in attrMap){\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if(attrVal === true && options.suppressBooleanAttributes){\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            }else{\n                attrStr+= ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options){\n    jPath = jPath.substr(0,jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for(let index in options.stopNodes){\n        if(options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\"+tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options){\n    if(textValue && textValue.length > 0 && options.processEntities){\n      for (let i=0; i< options.entities.length; i++) {\n        const entity = options.entities[i];\n        textValue = textValue.replace(entity.regex, entity.val);\n      }\n    }\n    return textValue;\n  }\nmodule.exports = toXml;"]},"metadata":{},"sourceType":"script"}