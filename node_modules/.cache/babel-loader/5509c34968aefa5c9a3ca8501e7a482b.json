{"ast":null,"code":"'use strict'; ///@ts-check\n\nvar _defineProperty = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _classCallCheck = require(\"/home/runner/work/watchparty/watchparty/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar util = require('../util');\n\nvar xmlNode = require('./xmlNode');\n\nvar readDocType = require(\"./DocTypeReader\");\n\nvar toNumber = require(\"strnum\");\n\nvar regx = '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'.replace(/NAME/g, util.nameRegexp); //const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nvar OrderedObjParser = function OrderedObjParser(options) {\n  _classCallCheck(this, OrderedObjParser);\n\n  this.options = options;\n  this.currentNode = null;\n  this.tagsNodeStack = [];\n  this.docTypeEntities = {};\n  this.lastEntities = {\n    \"amp\": {\n      regex: /&(amp|#38|#x26);/g,\n      val: \"&\"\n    },\n    \"apos\": {\n      regex: /&(apos|#39|#x27);/g,\n      val: \"'\"\n    },\n    \"gt\": {\n      regex: /&(gt|#62|#x3E);/g,\n      val: \">\"\n    },\n    \"lt\": {\n      regex: /&(lt|#60|#x3C);/g,\n      val: \"<\"\n    },\n    \"quot\": {\n      regex: /&(quot|#34|#x22);/g,\n      val: \"\\\"\"\n    }\n  };\n  this.htmlEntities = {\n    \"space\": {\n      regex: /&(nbsp|#160);/g,\n      val: \" \"\n    },\n    // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n    // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n    // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n    // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n    // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n    \"cent\": {\n      regex: /&(cent|#162);/g,\n      val: \"¢\"\n    },\n    \"pound\": {\n      regex: /&(pound|#163);/g,\n      val: \"£\"\n    },\n    \"yen\": {\n      regex: /&(yen|#165);/g,\n      val: \"¥\"\n    },\n    \"euro\": {\n      regex: /&(euro|#8364);/g,\n      val: \"€\"\n    },\n    \"copyright\": {\n      regex: /&(copy|#169);/g,\n      val: \"©\"\n    },\n    \"reg\": {\n      regex: /&(reg|#174);/g,\n      val: \"®\"\n    },\n    \"inr\": {\n      regex: /&(inr|#8377);/g,\n      val: \"₹\"\n    }\n  };\n  this.addExternalEntities = addExternalEntities;\n  this.parseXml = parseXml;\n  this.parseTextData = parseTextData;\n  this.resolveNameSpace = resolveNameSpace;\n  this.buildAttributesMap = buildAttributesMap;\n  this.isItStopNode = isItStopNode;\n  this.replaceEntitiesValue = replaceEntitiesValue;\n  this.readStopNodeData = readStopNodeData;\n  this.saveTextToParentTag = saveTextToParentTag;\n};\n\nfunction addExternalEntities(externalEntities) {\n  var entKeys = Object.keys(externalEntities);\n\n  for (var i = 0; i < entKeys.length; i++) {\n    var ent = entKeys[i];\n    this.lastEntities[ent] = {\n      regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n      val: externalEntities[ent]\n    };\n  }\n}\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\n\n\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n\n    if (val.length > 0) {\n      if (!escapeEntities) val = this.replaceEntitiesValue(val);\n      var newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n\n      if (newval === null || newval === undefined) {\n        //don't parse\n        return val;\n      } else if (typeof newval !== typeof val || newval !== val) {\n        //overwrite\n        return newval;\n      } else if (this.options.trimValues) {\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      } else {\n        var trimmedVal = val.trim();\n\n        if (trimmedVal === val) {\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        } else {\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    var tags = tagname.split(':');\n    var prefix = tagname.charAt(0) === '/' ? '/' : '';\n\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n\n  return tagname;\n} //TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\n\n\nvar attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n    var matches = util.getAllMatches(attrStr, attrsRegx);\n    var len = matches.length; //don't make it inline\n\n    var attrs = {};\n\n    for (var i = 0; i < len; i++) {\n      var attrName = this.resolveNameSpace(matches[i][1]);\n      var oldVal = matches[i][4];\n      var aName = this.options.attributeNamePrefix + attrName;\n\n      if (attrName.length) {\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n\n          oldVal = this.replaceEntitiesValue(oldVal);\n          var newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n\n          if (newVal === null || newVal === undefined) {\n            //don't parse\n            attrs[aName] = oldVal;\n          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n            //overwrite\n            attrs[aName] = newVal;\n          } else {\n            //parse\n            attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n\n    if (this.options.attributesGroupName) {\n      var attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n\n    return attrs;\n  }\n}\n\nvar parseXml = function parseXml(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n\n  var xmlObj = new xmlNode('!xml');\n  var currentNode = xmlObj;\n  var textData = \"\";\n  var jPath = \"\";\n\n  for (var i = 0; i < xmlData.length; i++) {\n    //for each char in XML data\n    var ch = xmlData[i];\n\n    if (ch === '<') {\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if (xmlData[i + 1] === '/') {\n        //Closing Tag\n        var closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n        var tagName = xmlData.substring(i + 2, closeIndex).trim();\n\n        if (this.options.removeNSPrefix) {\n          var colonIndex = tagName.indexOf(\":\");\n\n          if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n          }\n        }\n\n        if (currentNode) {\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n        currentNode = this.tagsNodeStack.pop(); //avoid recurssion, set the parent tag scope\n\n        textData = \"\";\n        i = closeIndex;\n      } else if (xmlData[i + 1] === '?') {\n        var tagData = readTagExp(xmlData, i, false, \"?>\");\n        if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {} else {\n          var childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n\n          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath);\n          }\n\n          currentNode.addChild(childNode);\n        }\n\n        i = tagData.closeIndex + 1;\n      } else if (xmlData.substr(i + 1, 3) === '!--') {\n        var endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n\n        if (this.options.commentPropName) {\n          var comment = xmlData.substring(i + 4, endIndex - 2);\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n          currentNode.add(this.options.commentPropName, [_defineProperty({}, this.options.textNodeName, comment)]);\n        }\n\n        i = endIndex;\n      } else if (xmlData.substr(i + 1, 2) === '!D') {\n        var result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      } else if (xmlData.substr(i + 1, 2) === '![') {\n        var _closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n\n        var tagExp = xmlData.substring(i + 9, _closeIndex);\n        textData = this.saveTextToParentTag(textData, currentNode, jPath); //cdata should be set even if it is 0 length string\n\n        if (this.options.cdataPropName) {\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [_defineProperty({}, this.options.textNodeName, tagExp)]);\n        } else {\n          var val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if (!val) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n\n        i = _closeIndex + 2;\n      } else {\n        //Opening tag\n        var _result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n\n        var _tagName = _result.tagName;\n        var _tagExp = _result.tagExp;\n        var attrExpPresent = _result.attrExpPresent;\n        var _closeIndex2 = _result.closeIndex; //save text as child node\n\n        if (currentNode && textData) {\n          if (currentNode.tagname !== '!xml') {\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        if (_tagName !== xmlObj.tagname) {\n          jPath += jPath ? \".\" + _tagName : _tagName;\n        } //check if last tag was unpaired tag\n\n\n        var lastTag = currentNode;\n\n        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n          currentNode = this.tagsNodeStack.pop();\n        }\n\n        if (this.isItStopNode(this.options.stopNodes, jPath, _tagName)) {\n          //TODO: namespace\n          var tagContent = \"\"; //self-closing tag\n\n          if (_tagExp.length > 0 && _tagExp.lastIndexOf(\"/\") === _tagExp.length - 1) {} //boolean tag\n          else if (this.options.unpairedTags.indexOf(_tagName) !== -1) {} //normal tag\n          else {\n            //read until closing tag is found\n            var _result2 = this.readStopNodeData(xmlData, _tagName, _closeIndex2 + 1);\n\n            if (!_result2) throw new Error(\"Unexpected end of \".concat(_tagName));\n            i = _result2.i;\n            tagContent = _result2.tagContent;\n          }\n\n          var _childNode = new xmlNode(_tagName);\n\n          if (_tagName !== _tagExp && attrExpPresent) {\n            _childNode[\":@\"] = this.buildAttributesMap(_tagExp, jPath);\n          }\n\n          if (tagContent) {\n            tagContent = this.parseTextData(tagContent, _tagName, jPath, true, attrExpPresent, true, true);\n          }\n\n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n\n          _childNode.add(this.options.textNodeName, tagContent);\n\n          currentNode.addChild(_childNode);\n        } else {\n          //selfClosing tag\n          if (_tagExp.length > 0 && _tagExp.lastIndexOf(\"/\") === _tagExp.length - 1) {\n            if (_tagName[_tagName.length - 1] === \"/\") {\n              //remove trailing '/'\n              _tagName = _tagName.substr(0, _tagName.length - 1);\n              _tagExp = _tagName;\n            } else {\n              _tagExp = _tagExp.substr(0, _tagExp.length - 1);\n            }\n\n            var _childNode2 = new xmlNode(_tagName);\n\n            if (_tagName !== _tagExp && attrExpPresent) {\n              _childNode2[\":@\"] = this.buildAttributesMap(_tagExp, jPath);\n            }\n\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n            currentNode.addChild(_childNode2);\n          } //opening tag\n          else {\n            var _childNode3 = new xmlNode(_tagName);\n\n            this.tagsNodeStack.push(currentNode);\n\n            if (_tagName !== _tagExp && attrExpPresent) {\n              _childNode3[\":@\"] = this.buildAttributesMap(_tagExp, jPath);\n            }\n\n            currentNode.addChild(_childNode3);\n            currentNode = _childNode3;\n          }\n\n          textData = \"\";\n          i = _closeIndex2;\n        }\n      }\n    } else {\n      textData += xmlData[i];\n    }\n  }\n\n  return xmlObj.child;\n};\n\nvar replaceEntitiesValue = function replaceEntitiesValue(val) {\n  if (this.options.processEntities) {\n    for (var entityName in this.docTypeEntities) {\n      var entity = this.docTypeEntities[entityName];\n      val = val.replace(entity.regx, entity.val);\n    }\n\n    for (var _entityName in this.lastEntities) {\n      var _entity = this.lastEntities[_entityName];\n      val = val.replace(_entity.regex, _entity.val);\n    }\n\n    if (this.options.htmlEntities) {\n      for (var _entityName2 in this.htmlEntities) {\n        var _entity2 = this.htmlEntities[_entityName2];\n        val = val.replace(_entity2.regex, _entity2.val);\n      }\n    }\n  }\n\n  return val;\n};\n\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) {\n    //store previously collected data as textNode\n    if (isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0;\n    textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false, isLeafNode);\n    if (textData !== undefined && textData !== \"\") currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n\n  return textData;\n} //TODO: use jPath to simplify the logic\n\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\n\n\nfunction isItStopNode(stopNodes, jPath, currentTagName) {\n  var allNodesExp = \"*.\" + currentTagName;\n\n  for (var stopNodePath in stopNodes) {\n    var stopNodeExp = stopNodes[stopNodePath];\n    if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;\n  }\n\n  return false;\n}\n/**\n * Returns the tag Expression and where it is ending handling single-dobule quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\n\n\nfunction tagExpWithClosingIndex(xmlData, i) {\n  var closingChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \">\";\n  var attrBoundary;\n  var tagExp = \"\";\n\n  for (var index = i; index < xmlData.length; index++) {\n    var ch = xmlData[index];\n\n    if (attrBoundary) {\n      if (ch === attrBoundary) attrBoundary = \"\"; //reset\n    } else if (ch === '\"' || ch === \"'\") {\n      attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if (closingChar[1]) {\n        if (xmlData[index + 1] === closingChar[1]) {\n          return {\n            data: tagExp,\n            index: index\n          };\n        }\n      } else {\n        return {\n          data: tagExp,\n          index: index\n        };\n      }\n    } else if (ch === '\\t') {\n      ch = \" \";\n    }\n\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n  var closingIndex = xmlData.indexOf(str, i);\n\n  if (closingIndex === -1) {\n    throw new Error(errMsg);\n  } else {\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData, i, removeNSPrefix) {\n  var closingChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \">\";\n  var result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n  if (!result) return;\n  var tagExp = result.data;\n  var closeIndex = result.index;\n  var separatorIndex = tagExp.search(/\\s/);\n  var tagName = tagExp;\n  var attrExpPresent = true;\n\n  if (separatorIndex !== -1) {\n    //separate tag name and attributes expression\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n    tagExp = tagExp.substr(separatorIndex + 1);\n  }\n\n  if (removeNSPrefix) {\n    var colonIndex = tagName.indexOf(\":\");\n\n    if (colonIndex !== -1) {\n      tagName = tagName.substr(colonIndex + 1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent\n  };\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\n\n\nfunction readStopNodeData(xmlData, tagName, i) {\n  var startIndex = i;\n\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === \"<\" && xmlData[i + 1] === \"/\") {\n      var closeIndex = findClosingIndex(xmlData, \">\", i, \"\".concat(tagName, \" is not closed\"));\n      var closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n\n      if (closeTagName === tagName) {\n        return {\n          tagContent: xmlData.substring(startIndex, i),\n          i: closeIndex\n        };\n      }\n\n      i = closeIndex;\n    }\n  } //end for loop\n\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    var newval = val.trim();\n    if (newval === 'true') return true;else if (newval === 'false') return false;else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\nmodule.exports = OrderedObjParser;","map":{"version":3,"sources":["/home/runner/work/watchparty/watchparty/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"],"names":["util","require","xmlNode","readDocType","toNumber","regx","replace","nameRegexp","OrderedObjParser","options","currentNode","tagsNodeStack","docTypeEntities","lastEntities","regex","val","htmlEntities","addExternalEntities","parseXml","parseTextData","resolveNameSpace","buildAttributesMap","isItStopNode","replaceEntitiesValue","readStopNodeData","saveTextToParentTag","externalEntities","entKeys","Object","keys","i","length","ent","RegExp","tagName","jPath","dontTrim","hasAttributes","isLeafNode","escapeEntities","undefined","trimValues","trim","newval","tagValueProcessor","parseValue","parseTagValue","numberParseOptions","trimmedVal","tagname","removeNSPrefix","tags","split","prefix","charAt","attrsRegx","attrStr","ignoreAttributes","matches","getAllMatches","len","attrs","attrName","oldVal","aName","attributeNamePrefix","newVal","attributeValueProcessor","parseAttributeValue","allowBooleanAttributes","attributesGroupName","attrCollection","xmlData","xmlObj","textData","ch","closeIndex","findClosingIndex","substring","colonIndex","indexOf","substr","lastIndexOf","pop","tagData","readTagExp","Error","ignoreDeclaration","ignorePiTags","childNode","add","textNodeName","tagExp","attrExpPresent","addChild","endIndex","commentPropName","comment","result","entities","cdataPropName","lastTag","unpairedTags","stopNodes","tagContent","push","child","processEntities","entityName","entity","currentTagName","allNodesExp","stopNodePath","stopNodeExp","tagExpWithClosingIndex","closingChar","attrBoundary","index","data","str","errMsg","closingIndex","separatorIndex","search","startIndex","closeTagName","shouldParse","isExist","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"amp\" : { regex: /&(amp|#38|#x26);/g, val : \"&\"},\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"¢\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"£\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"¥\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"€\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"©\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"®\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"₹\" },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      const aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n        \n        currentNode = this.tagsNodeStack.pop();//avoid recurssion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath);\n          }\n          currentNode.addChild(childNode);\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + \".\" + this.options.cdataPropName, true, false, true);\n          // if(!val) val = \"\";\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);\n          if(!val) val = \"\";\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n       \n        let result = readTagExp(xmlData,i, this. options.removeNSPrefix);\n        let tagName= result.tagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n        }\n\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){}\n          //boolean tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){}\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${tagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          currentNode.addChild(childNode);\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            \n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\n            }\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n            currentNode.addChild(childNode);\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\n            }\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nconst replaceEntitiesValue = function(val){\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-dobule quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n    tagExp = tagExp.substr(separatorIndex + 1);\n  }\n\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\" && xmlData[i+1] === \"/\"){ \n        const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n        let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n        if(closeTagName === tagName){\n          return {\n            tagContent: xmlData.substring(startIndex, i),\n            i : closeIndex\n          }\n        }\n        i=closeIndex;\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n"]},"metadata":{},"sourceType":"script"}